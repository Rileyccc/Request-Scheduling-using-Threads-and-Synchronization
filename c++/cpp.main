
#include<stdio.h>
#include<string.h>
#include<pthread.h>
#include<stdlib.h>
#include<unistd.h>
#include <semaphore.h>

class BoundedBuffer{
	public;
		void Producer();
		void Consumer();
	private;
		items buffer;
		semaphore mutex;
		semaphore empty;
		semaphore full;
	
}
BoundedBuffer ::BoundedBuffer(int N) {
	mutex.value = 1;
	empty value = N;
	
	full.value = 0;
	new buffer[N];
}

BoundedBuffer::Producer(){
	<produce item>
	empty.Wait();
	mutex.Wait();
	
	addRequest(); // add item
	
	mutex.Signal();
	full.Signal()
}

BoundedBuffer::Consumer(){
	full.Wait();
	mutex.Wait();
	
	removeRequest(); // remove item
	
	mutex.Signal();
	empty.Signal(;
	
	// use item

}

class semaphore{
	public;
		void Wait(Process P);
		void Signal();
	private
		int value;
		queue Q; 
}

semaphore(int val){
	value = val;
	Q = empty
}

Wait(process P){
	value = value - 1;
	if (value < 0) {
		add P to Q;
		P->block();
} }
Signal(){
value = value + 1;
if (value <= 0) {
	remove P from Q;
	wakeup(P);
}
}


// riley's java for reference

class main { 
int N = 10;
int M = 1; 

BoundedBuffer boundedBuffer = new BoundedBuffer(N)

int requestID = 1;
int requestLength = 0;
Request r = null;

while(true) {
			
			try {
				// make masterThread sleep for random amount of time
				sleep(thread)*(int)((Math.random()*N) *1000);
			
				// calculate request length
				requestLength = (int)(Math.random() * M + 1);
				
//				Producer: produced request ID n, length t seconds at time CURRENT-TIME
//				Producer: sleeping for X seconds
				
				//create new request
				r = new Request(requestId++, requestLength);
				printf("Producer: produced request ID %d, length %d seconds at time %d\n", requestId, requestId, System.currentTimeMillis());
				//add request to bounded buffer
				boundedBuffer.addRequest(r);
				
				producerSleepTimer = (int)((Math.random()*4));
				
				printf("Producer: sleeping for %d seconds\n", producerSleepTimer);
				
				// make masterThread sleep for random amount of time
				Thread.sleep(producerSleepTimer*1000);
				
				
				
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			
		}
	}
}
